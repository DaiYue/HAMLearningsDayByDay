# 即兴提问和即兴分享

Q : 当我们写下@property时我们在写什么？

A : 

1. 生成一个叫_foo的成员变量 2.声明 foo,setFoo 两个getter setter方法 3.默认实现这两个方法
      
实际上以前第1步是要手动声明，第3步是要写一句@synthesize的，不过现在一般情况不用写。只有你把getter setter都重写的情况下，编译会报错，就说没有_foo这个成员变量呀？这时候你还是要写一句@synthesize

前天我问大家category怎么加property，答案是关联对象。一位同学说，不对呀，category里可以写@property呀？是可以，protocol里也可以。然而，这里写的@property，相当于只有第2步，没有第1 3步。所以，它实际上是只声明了getter setter，而没有真正开辟一块存储对象的空间，并把getter setter与这个对象绑定。相当于只挂了门牌号，没有房子。只有手机号，没有手机。而关联对象做的是什么？做的是第1步。第1步做好，第2 3步你可以按自己的需要去做。第一部分就讲这么多。

下面讲第二部分，weak strong assign copy。前三个是一组。想必大家都知道weak strong有什么区别，对于OC中的对象，有一个“引用计数”的概念。比如，我声明了一个临时变量，Foo* foo =new Foo(); 那么系统就生成了一个Foo对象，并用foo这个指针指向它。这时候这个对象的引用计数是多少？是1，因为foo这个指针持有它。下面我把它赋给一个strong的属性，self.foo=foo; 现在引用计数是多少？是2。然后这个函数结束了。这时候引用计数变成多少？变成1。因为foo这个临时变量被销毁了，所以引用计数减一。那么，如果这个属性不是strong，而是weak呢？self.foo=foo，仍然把这个指针的值保存在了self.foo里。只不过区别在于，引用计数不加一。所以引用计数仍然是1。那么，函数结束时发生了什么呢？像上面一样，foo这个临时变量销毁时，引用计数要减一。这时候引用计数就变成了0。对象就被系统回收了。以上就是strong 和weak的区别。

weak类型的属性，在对象被回收的时候，会做一个特殊处理：把这个属性置为nil。以后我们可以讨论下这个特殊机制怎么实现的，这应该算是个比较高阶的面试题。之后我们再访问self.foo，它的值就是nil了。那么，缺了这一步会怎样，有哪些危险呢？这种情况下，指针仍然指向那一块内存。然而，管内存管理的哥们，并不知道这块内存有人用。当我们使用这个属性的值，就像刻舟求剑一样，就像一个人坐过一次火车，下次他还去同一个站台坐火车，然而火车开往哪个终点，很可能完全不一样了。这种情况，非常危险，很可能引起crash。主要原因在于，
                
1. 这块内存后来又被分给了其他对象，写上了别的数据。当我还取这个属性时，那块内存已面目全非，根本取不出一个完整的foo了。于是系统就果断crash。

2. 就是相反地，别的对象已经占用了这块空间，那么我再给这个 foo 赋值，又会把别的对象已有的数据写坏。那么一旦用到那个对象，必定又要出问题。

3. 对象销毁的时候，也可能会 crash。如果大家切到 MRC 模式，new 出一个对象，然后 release 两次，就要 crash。这能解释孙总昨天的问题，为何他写了一个 assign 的属性，然后 self.foo = [Foo new]; 就会 crash。而 Foo* foo = [Foo new]; self.foo = foo; 就不会 crash，因为此时局部变量 foo 还引用着这个对象，引用计数还是 1，表面还是正常的。当然这个函数结束之后，局部变量被释放，也就进入不正常的模式了。以上能告诉我们的就是，一定不要用 assign 修饰一个对象类型，这样很不安全。关于刚才说的引用计数，大家可能会有一个疑问，比如 Foo* foo = [Foo new]; return foo; 当我 return 的时候，局部变量 foo 不是应该销毁嘛，那接收方怎么接到的？这又是一个比较难一点的面试题…… 我们以后可以继续讨论 O    O

昨天我们讲了 strong、weak、assign，下面我们讲一下 copy ……copy 跟前面三个含义不一样，它表示的是 setter 方法会对参数进行一次拷贝，然后再储存起来。这里提一个小问题：既然如此，为何把这个 copy 关键字跟 strong、weak、assign 它们放在一组呢？为何不设计成 copy 能分别跟 strong、weak 组合呢？系统有一些常见的类可以 copy，比如 NSString、NSArray、NSDictionary。而也有一些不能，比如 UIView、UIViewController。想知道一个类能不能写 copy，只需查看它是否实现了 NSCopying 协议.而咱们要想让自己的类支持 copy ，也需要实现这个协议，并且实现其中唯一的方法 - copyWithZone

关于 copy 方法的实现，还有两点需要注意的：1. 实现时一定要是深拷贝，不然就没有实现 copy 的语义，让使用者迷惑，造成意外的结果 2. 注意几个 mutable 的类不能用 copy 修饰，这个咱们之前讲过。无论是 NSArray 还是 NSMutableArray，只要 copy 出来的都是不可变的，只要 mutableCopy 出来都是可变的

atomic 和 nonatomic...如果不写这两个关键字，系统会默认选择哪一个呢？系统默认是 atomic。但是，在 iOS 上我们一般要显式写 nonatomic，OSX 里就用默认的 atomic 就好。这是因为 atomic 更安全，但耗性能。nonatomic 相反。在手机上性能比较紧张， 电脑上就可以豪爽一点，所以是这么设定的。注意两个点：

1. atomic 是否能保证线程安全？答案一定是不能。线程安全是没有这么简单的，需要在逻辑上按自己的需求进行限制，而 atomic 只是做了一点小小的防护而已。

2. 基本类型用 atomic 和 nonatomic 是有区别的吗？这个问题我之前想过，没有查到定论，仓鼠谨慎地表示，应该是没有区别的。具体有没有区别，还得看汇编之后的指令情况，这个我没有看过 O    O 不过一个间接的证据是，关联对象时的策略，对于 assign 只有： `OBJC_ASSOCIATION_ASSIGN` 而对于 retain (就是咱们平常用的 strong) 就有 `OBJC_ASSOCIATION_RETAIN`、`OBJC_ASSOCIATION_RETAIN_NONATOMIC`。当然，这不能算是什么铁证，只是我的猜测。后面有机会我会专门研究一下这个问题的。

---

Q : 为何把这个 copy 关键字跟 strong、weak、assign 它们放在一组呢？为何不设计成 copy 能分别跟 strong、weak 组合呢？

A : 答案很简单，看过前几天讨论的同学一定能明白~ copy 是在 setter 里使用 copyWithZone 方法生成一个新对象，如果没有人 retain 这个新对象，那么一下子就释放掉了。等于 setter 就是无效的。所以，copy 一定会 retain，也就一定是 strong。所以，没有必要再指定 weak、strong了。
